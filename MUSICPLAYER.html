<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MUSICPLAYER</title>
<style>
	:root { color-scheme: dark; }
	button { font-size: 300%; padding: 2px 2px 2px 2px; background-color: rgba(0,0,0,0); border: none; }
	button:hover { background-color: gray; }
	#clear_timestamps { font-size: 100%; }
	select { font-size: 24pt; width:90%; max-width:80%; }
	option { font-size: 18pt; }
	audio { background-color: rgba(0,0,0,0.00); width: 90%; }
	audio::-webkit-media-controls-play-button { transform-origin: center center; transform: scale(2,2.5); }
	#log_table:has(#log_table_body:empty) { display: none; }  /* The :has modifier does not work in firefox just yet. */
	#log_table { font-size:10pt; word-wrap:break-word; font-family: Consolas, monaco, monospace; }
	#log_table tr { transition: 1s opacity ease-in, 0.5s height ease; }
</style>
<style id="CSS_screen_wake_lock">
	/* Screen wake lock css, for the fancy togglabe slider */
	.slider-toggle-switch { --slider-ts-width: 65px;--slider-ts-height: 30px; --slider-ts-switch-width: 30px; --slider-ts-color: #3498db; --slider-ts-color-unchecked: #ccc; --slider-ts-shadow-color: rgba(0, 0, 0, 0.5); --slider-ts-input-font-size: 0.8rem; --slider-ts-input-font-color: #fff; --slider-ts-input-checked-content: "ON"; --slider-ts-input-unchecked-content: "OFF"; --slider-ts-switch-background-color: #fff; --slider-ts-label-color: #000; color: var(--slider-ts-input-font-color); display: inline-flex; align-items: center; user-select: none; position: relative; vertical-align: middle; margin-bottom: 0; }
	.slider-toggle-switch:hover { cursor: pointer; }
	.slider-toggle-switch>input[type="checkbox"] { position: absolute; opacity: 0; }
	.slider-toggle-switch>input[type="checkbox"]+.slider_toggle { border-radius: 4px; align-items: center; position: relative; overflow: hidden; flex-shrink: 0; width: var(--slider-ts-width); height: var(--slider-ts-height); margin: 0; cursor: pointer; transition: background 200ms linear, box-shadow 200ms linear; }
	.slider-toggle-switch>input[type="checkbox"]+.slider_toggle:before { content: var(--slider-ts-input-checked-content); opacity: 0; }
	.slider-toggle-switch>input[type="checkbox"]+.slider_toggle:after { content: var(--slider-ts-input-unchecked-content); left: var(--slider-ts-switch-width); }
	.slider-toggle-switch>input[type="checkbox"]+.slider_toggle:before,
	.slider-toggle-switch>input[type="checkbox"]+.slider_toggle:after { display: flex; align-items: center; position: absolute; z-index: 2; height: 100%; justify-content: center; width: calc(100% - var(--slider-ts-switch-width)); font-size: var(--slider-ts-input-font-size); transition: all 200ms linear; }
	.slider-toggle-switch>input[type="checkbox"]+.slider_toggle>.slider_switch { background-color: var(--slider-ts-switch-background-color); border-radius: 6px; display: block; height: 100%; width: var(--slider-ts-switch-width); position: absolute; right: 0; z-index: 3; box-sizing: border-box; transition: right 200ms linear, border-color 200ms linear; }
	.slider-toggle-switch>input[type="checkbox"]:checked+.slider_toggle { background-color: var(--slider-ts-color); }
	.slider-toggle-switch>input[type="checkbox"]:checked+.slider_toggle:before { opacity: 1; }
	.slider-toggle-switch>input[type="checkbox"]:checked+.slider_toggle:after { opacity: 0; }
	.slider-toggle-switch>input[type="checkbox"]:checked+.slider_toggle>.slider_switch { border-width: 3px; border-style: solid; border-color: var(--slider-ts-color); }
	.slider-toggle-switch>input[type="checkbox"]:not(:checked)+.slider_toggle { background-color: var(--slider-ts-color-unchecked); }
	.slider-toggle-switch>input[type="checkbox"]:not(:checked)+.slider_toggle>.slider_switch { border-width: 3px; border-style: solid; border-color: var(--slider-ts-color-unchecked); right: calc(100% - var(--slider-ts-switch-width)); }
</style>
<script src="custom.js"> /* load CUSTOM_PLAYLISTS_TO_LOAD and INDIVIDUAL_TRACKS_TO_LOAD */ </script>
<script>
	var PLAYER_HISTORY_STACK = [];
	var PLAYLIST_SONGS = [];
	/**
	 * @params - You can give it a list of strings that include the 
	 * - "name" of the song.
	 * - "key" of the song -> the `/artist/song/` part of the mixcloud.com/artist/song/ url.
	 * - "src" of the song. -> the full url of the audio to be used as the source when loaded.
	 * OR you can give it a dict with "name", "key", and/or "src" key value pairs.
	 * valid usage:
	 * add_song_record_to_playlist("RONS: Podcast #420", "/therealrons/rons-podcast-420/")
	 * add_song_record_to_playlist("RONS: Podcast #420", "/therealrons/rons-podcast-420/", "https://stream5.mixcloud.com/secure/c/m4a/64/2/7/3/3/c31f-6b26-42c6-814d-2051f42337fc.m4a?sig=woS4_8jGlXDNMX-TmIuEnQ")
	 * add_song_record_to_playlist({name:"RONS: Podcast #420", key:"/therealrons/rons-podcast-420/", src:"https://stream5.mixcloud.com/secure/c/m4a/64/2/7/3/3/c31f-6b26-42c6-814d-2051f42337fc.m4a?sig=woS4_8jGlXDNMX-TmIuEnQ"})
	 * add_song_record_to_playlist({name:"RONS: Podcast #420", key:"/therealrons/rons-podcast-420/"})
	 */
	function add_song_record_to_playlist() {
		function validate_song_record() {
			var temp = {};
			for (var x of arguments) {
				if (x == null) {
					continue;
				}
				if (typeof(x) == 'object' && (x.src || (x.name && x.key))) {
					return validate_song_record(x?.name, x?.key, x?.src);
				}
				if (x?.toString().match(/^\/.*?\/.*?\/$/gmi)) {
					// then its a key
					temp['key'] = x;
				} else if (x?.toString().match(/https?:\/\/.*\..*/gmi)){
					temp['src'] = x;
				} else {
					temp['name'] = x;
				}
			}
			return (((temp['src'] || (temp['key'] && temp['name'])) || false) && true ? temp : null);
		}
		function does_song_record_already_exist(record) {
			for (var row of PLAYLIST_SONGS) {
				if ((record.key && row.key && record.key == row.key) || (record.src && row.src && record.src == row.src)) 
					return true
			}
			return false;
		}
		var song = validate_song_record(...arguments)
		
		if (song && song != {} && !does_song_record_already_exist(song)) {
			PLAYLIST_SONGS.push(song);
		}
	}
	
	/**
	 * Loads custom list of songs from mixcloud into the global {@linkcode PLAYLIST_SONGS} variable.
	 * This function is also responsible for formatting the new records for {@linkcode PLAYLIST_SONGS} name of the song.
	 * @param {HTMLElement=} debug - If given, it may use this HTMLElement (or subclass of HTMLElement) as a debugging print line.
	 */
	async function load_custom_songs(debug=null, mixcloud_search_query, mixcloud_match_regex, name_to_replace, name_replace_with) {
		if (typeof(mixcloud_match_regex) == "string") {
			mixcloud_match_regex = new RegExp(mixcloud_match_regex, "gmi")
		}
		var search_queue = [`https://api.mixcloud.com/search/?limit=100&q=${mixcloud_search_query}&type=cloudcast`];
		if (debug) { debug.innerText = `${PLAYLIST_SONGS.length} songs loaded`;}
		while (search_queue.length > 0) {
			if (debug) { debug.innerText = debug.innerText.replace(new RegExp('(\\d+) songs loaded(\.*)', 'gm'), `${PLAYLIST_SONGS.length} songs loaded $2.`); }
			var search_url = search_queue.pop();
			var search_results = await get_JSON(search_url);
			if ('data' in search_results) {
				for (var i in search_results['data']) {
					if (mixcloud_match_regex.exec(search_results['data'][i]['name']) !== null || mixcloud_match_regex.exec(search_results['data'][i]['user']['username']) !== null) {
						add_song_record_to_playlist(name=search_results['data'][i]['name'].replace(name_to_replace, name_replace_with), key=search_results['data'][i]['key'])
						if (debug) { debug.innerText = debug.innerText.replace(new RegExp('(\\d+) songs loaded(\.*)', 'gm'), `${PLAYLIST_SONGS.length} songs loaded $2`); }
						document.title = `${PLAYLIST_SONGS.length} songs loaded...`;
					}
				}
			}
			if ('paging' in search_results) {
				if ('next' in search_results['paging']) {
					search_queue.push(search_results['paging']['next'])
				}
			}
		}
	}
	
	/** 
	 * README | EDIT HERE | NOTE | README | EDIT HERE | NOTE | README | EDIT HERE | NOTE | README | EDIT HERE | NOTE
	 * Custom func for filling PLAYLIST_SONGS with whatever you want
	 * See load_custom_songs for an example for how to load songs from mixcloud searches.
	 * See add_song_record_to_playlist for how to add songs to the master playlist.
	 * README | EDIT HERE | NOTE | README | EDIT HERE | NOTE | README | EDIT HERE | NOTE | README | EDIT HERE | NOTE
	*/
	async function update_playlist_songs() {
		var prog = document.querySelector("#songlist_selector").querySelector("option");
		prog.innerText = `${PLAYLIST_SONGS.length} songs loaded`;
		if (Date.now() - load_persistent('PERSISTENT_PLAYLIST_GEN_DATE') <= 86400000 && PLAYLIST_SONGS.length > 10) {
			// if last load time was in the last 24hrs and it seems we actually have a bunch of songs, then dont regenerate the playlist
			console.log('done updating my song playlist. If this is wrong, reload the page with the Enable persistent storage of playlist checkbox disabled!');
			return true;
		}
		if (CUSTOM_PLAYLISTS_TO_LOAD == undefined) {
			write2log(`Missing CUSTOM_PLAYLISTS_TO_LOAD from custom.js!`);
		} else {
			for (var opt of CUSTOM_PLAYLISTS_TO_LOAD ?? []) {
				await load_custom_songs(debug=prog, mixcloud_search_key=opt.mixcloud_search_key, mixcloud_match_regex=opt.mixcloud_match_regex, name_to_replace=opt.name_to_replace, name_replace_with=opt.name_replace_with);
			}
		}
		if (INDIVIDUAL_TRACKS_TO_LOAD == undefined) {
			write2log(`Missing INDIVIDUAL_TRACKS_TO_LOAD from custom.js!`);
		} else {
			for (var track of INDIVIDUAL_TRACKS_TO_LOAD) {
			try {
				add_song_record_to_playlist(name=track.name, key=track.key);
			} catch {
				write2log(`Bad INDIVIDUAL_TRACKS_TO_LOAD: ${JSON.stringify(track)}`);
			}
			
		}
		}
		
		document.title = "Cleaning songs...";
		prog.innerText = `Cleaning ${PLAYLIST_SONGS.length} songs...`;
		// REMOVE BAD SONGS
		var BAD_SONGS = ['/therealrons/rons-podcast-665/','/FrankAndreasen/the-best-of-2018-the-dance-mixes/']; 	// EXAMPLE VALUES, EDIT THIS AS WE SEE FIT
		var i = PLAYLIST_SONGS.length - 1;
		while (i >= 0) {
			if (PLAYLIST_SONGS[i].name in BAD_SONGS || PLAYLIST_SONGS[i].key in BAD_SONGS) {
				PLAYLIST_SONGS = PLAYLIST_SONGS.splice(i, 1);
				prog.innerText = `${PLAYLIST_SONGS.length} songs loaded...`;
			}
			i -= 1;
		}
		console.log('done updating my song playlist');
		update_persistent('PERSISTENT_PLAYLIST_GEN_DATE',Date.now(), 0);
		return true;
	}

	/**
	 * Fetches the response from the URL. If offline, it will attempt to wait for up to `max_attempts=10` tries, 1 minutes each, for the connection to go back online.
	 * @param url <String> the url to get.
	 * @throws Exceptions that are raised while fetching the url (not including NetworkErrors), or an offline timeout error.
	 */
	async function get_successful_fetch(url) {
		function delay_until_connection(timeout_sec) {
			// Sleep until onLine or timeout.
			let end_at = Date.now() + (timeout_sec * 1000);
			while (!window.navigator.onLine) {
				if (Date.now() >= end_at) {
					throw("Timeout exception, offline for too long!")
				}
			}
		}
		var max_attempts = 10;
		var attempt = 0;
		let result = null;
		while (result == null && attempt++ < max_attempts) {
			try {
				return await fetch(url);
			} catch (err) {
				if (! err.message.startswith("NetworkError")) {
					throw err;
				}
				// else it is a network error, so keep waiting until we timeout in 60 seconds
				write2log(`get_successful_fetch(${url}); //Offline... waiting to reconnect...`,59);
				await delay_until_connection(60);
			}
		}
		throw(`Timed out trying to get ${url}`)
	}
	
	/**
	 * @param url <String> The url to extract JSON from.
	 * @returns result of JSON.parse.
	*/
	async function get_JSON(url) { write2log(`get_JSON(${url})`,2); let response = await get_successful_fetch(url); let data = await response.json(); return data; }
	
	/**
	 * @param key <String> the mixcloud key/url endpoint of the song to be retrieved.
	 * @returns <String> the url for the audio source of the given mixcloud key.
	 */
	async function retreive_audio_src(key) { 
		// write2log(`retreive_audio_src(${key})`,2);
		var logLines = [];
		logLines.push(write2log(`retreive_audio_src(${key})`));
		// Attempts to get the url for the src of the given mixcloud key
		var url = `https://justcors.com/l_n1ehx3zipc/https://www.dlmixcloud.com/ajax.php?url=https://www.mixcloud.com${key}`;
		var response = await get_successful_fetch(url)
		var result_text = await response.text()
		var resulting_json = JSON.parse(result_text)
		var value = resulting_json['url'];
		// new format: 
		if (!value) {
			logLines.push(write2log(`Attempted to get audio src link for ${key}, no 'url' key at level 0 in response`))
			for (var fmt of resulting_json['formats']) {
				if (fmt['format_id'] == 'http') {
					logLines.push(write2log(`Attempted to get audio src link for ${key}, found formats...format_id=='http' with url of '${fmt['url']}`))
					value = fmt['url'];
					break;
				}
			}
		}
		logLines.push(write2log(`returning: ${value}`))
		logLines.forEach(e=> removeFadeOutAfter(e, 5))
		return value;
	}
	
	/**
	 * Loads a random song index from the playlist queue, tries to not replay the last DONT_REPLAY_FROM_THE_LAST_X_SONGS songs.
	 * @CONFIG DONT_REPLAY_FROM_THE_LAST_X_SONGS - the number of songs from the history to not be repeated.
	 * @returns <int> An integer index for PLAYLIST_SONGS where the index is a randomly selcted song that hasnt been recently played.
	 */
	function get_random_song_idx(){
		const DONT_REPLAY_FROM_THE_LAST_X_SONGS = 5;
		var r = Math.floor(Math.random() * PLAYLIST_SONGS.length);
		if (PLAYER_HISTORY_STACK.length < DONT_REPLAY_FROM_THE_LAST_X_SONGS) {
			// no option to play a diff song.
			return r;
		}
		while (r in PLAYER_HISTORY_STACK.slice(-DONT_REPLAY_FROM_THE_LAST_X_SONGS)) {
			r = Math.floor(Math.random() * PLAYLIST_SONGS.length);
		}
		return r;
	}
	
	/**
	 * Loads up the next song from the playlist queue in a sequential order.
	 * @return <int> the integer index for PLAYLIST_SONGS of the next song to be played.
	 */
	function get_next_song_idx(){
		// 
		if (PLAYER_HISTORY_STACK.length == 0) {
			// no option to play a diff song.
			return 0;
		}
		return (PLAYER_HISTORY_STACK[0] + 1) % PLAYLIST_SONGS.length;
	}
	
	/**
	 * Stores timestamps of specific songs so that we can keep track of favorite songs etc.
	 * Will update the #timestamps_list element.
	 */
	function mark_favorited_timestamp(){
		var audio = document.querySelector('audio');
		var curr_timestamp = audio.currentTime;
		if (PLAYER_HISTORY_STACK.length == 0) {
			return;
		}
		var curr_song = PLAYLIST_SONGS[PLAYER_HISTORY_STACK[0]];
		var timestamp_list = document.querySelector('#timestamps_list');
		var li = document.createElement("li");
		li.innerText = `${curr_song.name} @ ${sec_to_human_readable_timestamp(curr_timestamp)}`;
		timestamp_list.appendChild(li);
	}
	
	/**
	 * @param sec <number> seconds.
	 * @returns <String> simplified timestamp.
	 */
	function sec_to_human_readable_timestamp(sec) {
		return `${String(parseInt(sec/3600)).padStart(2, '0')}:${String(parseInt((sec % 3600)/60)).padStart(2, '0')}:${parseInt(sec) % 60}`;
	}
	
	/**
	 * Event fired by selecting a song from the playlist dropdown.
	 * Loads the song from the index that matches the selected value (a key).
	 */
	function load_selected_song(){
		var selected_val = document.querySelector('select').value;
		var i = 0;
		while (i < PLAYLIST_SONGS.length) {
			if (PLAYLIST_SONGS[i].key == selected_val) {
				load_song_from_index(i);
				return;
			}
			++i;
		}
	}
	
	/**
	 * PREREQ: update_playlist_songs has been run
	 * If not given explicitly, gets the proper playlist index number, attempts to play that song, and updates the UI.
	 * @param next_song, <int> the index from the PLAYLIST_SONGS to use, <null>=0, <str> the song key from the PLAYLIST_SONGS to use.
	 */
	async function load_song_from_index(next_song=null){
		if (PLAYLIST_SONGS.length == 0) {
			return;
		}
		// is run when we want to start loading a new song into the player
		if (typeof(next_song) == 'number') {
			next_song = (parseInt(next_song) || 0) % PLAYLIST_SONGS.length;
		} else if (typeof(next_song) == 'string') {
			var s = next_song;
			next_song = 0;
			while (next_song < PLAYLIST_SONGS.length) {
				if (PLAYLIST_SONGS[next_song].name == s || PLAYLIST_SONGS[next_song].key == s) {
					break
				}
				++next_song;
			}
			if (next_song == PLAYLIST_SONGS.length) {
				next_song = get_random_song_idx();
			}
		} else {
			next_song = document.querySelector('#shuffle_button').innerText == "üîÄ" ? get_random_song_idx() : get_next_song_idx();
		}
		document.title = "Loading next song...";
		// now next_song is an int.
		if (PLAYLIST_SONGS[next_song].src == undefined) {
			do {
				try {
					PLAYLIST_SONGS[next_song].src = await retreive_audio_src(PLAYLIST_SONGS[next_song].key);
				} catch (err) {
					console.log(`Error while attempting to get src from song index #${next_song}, key = '${PLAYLIST_SONGS[next_song].key}', name = '${PLAYLIST_SONGS[next_song].name}', skipping to next index!`);
					next_song++;
				}
			} while (PLAYLIST_SONGS[next_song].src == undefined)
		} else {

		}

		// now we have the src for this song... its ready to be loaded
		await update_player_src(PLAYLIST_SONGS[next_song].src);
		
		// set currently playing in player history
		PLAYER_HISTORY_STACK.splice(0, 0, next_song);
		var dropdown_selections = document.getElementById('songlist_selector');
		dropdown_selections.value = PLAYLIST_SONGS[next_song].key;

		// update played history tab
		update_played_history_ui();

		// update title of webpage
		document.title = PLAYLIST_SONGS[next_song].name;
		update_mediasession_info(PLAYLIST_SONGS[next_song]);
	}

	/**
 	 * Updates the navagator.mediaSession object to reflect the given song.
	 */  
	function update_mediasession_info(song) {
		if ("mediaSession" in navigator) {
			try {
				var [artist, title] = song.name.split(": ",2);
				navigator.mediaSession.metadata = new MediaMetadata({
					title: title,
					artist: artist,
					//album: "Podcast Name",
					//artwork: [{ src: "podcast.jpg" }],
				});
				var audio_element = document.querySelector("audio");
				navigator.mediaSession.setPositionState({duration: audio_element.duration, playbackRate: audio_element.playbackRate, position: audio_element.currentTime});
			} catch (err) {}
		}
	}
	
	function setup_media_session_action_handlers() {
		if (!("mediaSession" in navigator)) {
			write2log(`No mediaSession in navigator.`,2);
		}
		const audio_element = document.querySelector('audio');
		const default_skip_time = 60; /* Time to skip in seconds by default */

		const action_handlers = [
			['play',			() => { audio_element.play(); }],
			['pause',			() => { audio_element.pause(); }],
			['previoustrack',	() => { audio_element.currentTime = 0; }],
			['nexttrack',		() => { load_song_from_index(); }],
			['stop',			() => {audio_element.pause(); }],
			['seekbackward',	(details) => {  const skip_time = details.seekOffset || default_skip_time; audio_element.currentTime = Math.max(audio_element.currentTime - skip_time, 0); navigator.mediaSession.setPositionState({duration: audio_element.duration, playbackRate: audio_element.playbackRate, position: audio_element.currentTime});}],
			['seekforward',		(details) => {  const skip_time = details.seekOffset || default_skip_time; audio_element.currentTime = Math.min(audio_element.currentTime + skip_time, 0); navigator.mediaSession.setPositionState({duration: audio_element.duration, playbackRate: audio_element.playbackRate, position: audio_element.currentTime});}],
			['seekto',		(details) => {  if (details.fastSeek && 'fastSeek' in audio_element) { audio_element.fastSeek(details.seekTime); } else { audio_element.currentTime = details.seekTime; } navigator.mediaSession.setPositionState({duration: audio_element.duration, playbackRate: audio_element.playbackRate, position: audio_element.currentTime});}],

			// Not implemented: ['togglemicrophone', 'togglecamera', 'hangup', 'previousslide', and 'nextslide'];
			/* Video conferencing actions */
			//['togglemicrophone',	() => { await audio_element.pause(); /* On any microphone usage (on or off), just set the audio to pause. */ }],
			//['togglecamera',	() => { await audio_element.pause(); /* On any camera usage (on or off), just set the audio to pause. */ }],
			//['hangup',		() => { if (audio_element.currentTime > 0) { await audio_element.play(); } /* On hangup, simplified (not bulletproof) version of unmute if we were playing music before */}],
			/* Presenting slides actions */ // Not implemented at this time, placeholder for future? idk.
			//['previousslide',	() => { /* ... */ }],
			//['nextslide',		() => { /* ... */ }],
		];
		for (const [action, handler] of action_handlers) {
			try {
				write2log(`Adding mediaSession action: ${action}`,5);
				navigator.mediaSession.setActionHandler(action, handler);
			} catch (error) {
				write2log(`The media session action "${action}" is not supported yet.`,2);
			}
		}
		try {
			// Set playback event listeners
			audio_element.addEventListener('play', () => { navigator.mediaSession.playbackState = 'playing'; });
			audio_element.addEventListener('pause', () => { navigator.mediaSession.playbackState = 'paused'; });
		}
		catch (err) {
			write2log(`Failed to set navigator.mediaSession.playbackState play/pause handlers`,2);
		}
	}

	
	/**
	 * Updates the played history tab UI with the current song info.
	 */
	function update_played_history_ui() {
		var history_list = document.querySelector('#played_history_list');
		var ul = document.createElement("ul");
		ul.setAttribute('id','played_history_list');
		PLAYER_HISTORY_STACK.forEach(e=>{
			var li = document.createElement("li"); 
			li.innerText = `${PLAYLIST_SONGS[e].name}`;
			ul.appendChild(li);
		});
		history_list.innerHTML = ul.innerHTML;
	}
	
	/**
	 * Updates the audio element with the given src url.
	 * If successfully played, will update the persistent LAST_SONG_SRC value so that you can quick start playing next time the musicplayer is open.
	 * @param src <str> the audio source string (url) to be played
	 */
	async function update_player_src(src) {
		if (src == null) {return;}
		var audio = document.querySelector('audio');
		var source = document.querySelector('source');
		source.setAttribute('src', src);
		try{
			audio.load();
			try{
				audio.play();
				audio.muted = false;
			}catch(err){}
			update_persistent('LAST_SONG_SRC', src, 0);	// save the src for the quickstart
			navigator.mediaSession?.setPositionState({duration: audio.duration, playbackRate: audio.playbackRate, position: audio.currentTime}); 
		}catch(err){}
	}

	/**
	 * Fired when a src fails to load in the audio player.
	 * Checks the playlist song records that use that src value and attepts to get the new updated SRC for them. 
	 * When successful it will update the src of the live PLAYLIST_SONG record.
	 * This is a background thread!
	 * @param src <str> the audio source string (url) to be checked for updates.
	 */
	function check_for_updated_src(src) {
		if (!src) {
			return null;
		}
		try {
			for (let e of PLAYLIST_SONGS) {
				if (e.src == src) {
					let ns = retreive_audio_src(e.key)
					.then(newSrc => {
						if (newSrc && e.src != newSrc) {
							e.src = newSrc; 
							write2log(`Updated ${e.key} src to ${newSrc}!`,2);
						}
					});
				}
			}
		} catch(err) {
			write2log(`some ${err} error while attempting to get updated src of ${song.key}`,2);
		}
	
	}

	/**
	 * Updates the dropdown UI to display all of the available songs in PLAYLIST_SONGS. 
	 * Will sort the PLAYLIST_SONGS.
	 * NOTE: This should be run after `update_playlist_songs`
	 */
	function update_dropdown_with_current_songs(){
		document.querySelector("#songlist_selector").querySelector("option").innerText = "Updating song selections...";
		var i = 0;
		var dropdown_selections = document.getElementById('songlist_selector').options;
		while (dropdown_selections.length > 0) {
			dropdown_selections[0].remove();
		}
		// Sort by name, then by key
		PLAYLIST_SONGS.sort((a,b) => (a.name.toLowerCase() > b.name.toLowerCase()) ? 1 : ((b.name.toLowerCase() > a.name.toLowerCase()) ? -1 : (a.key?.toLowerCase() > b.key?.toLowerCase()) ? 1 : ((b.key?.toLowerCase() > a.key?.toLowerCase()) ? -1 : 0)));
		while (i < PLAYLIST_SONGS.length) {
			dropdown_selections.add(new Option(PLAYLIST_SONGS[i].name,PLAYLIST_SONGS[i].key));
			++i;
		}
		
	}

	/** 
	 * Attempts to load a src value from the localStorage so that we can get music instantly instead of having to wait for the full dynamic load of the song list 
	 */
	function start_quick_start_song(){
		try {
			var src = load_persistent('LAST_SONG_SRC');
			if (src) {update_player_src(src);}
		} catch (err) {
			console.log("Unable to load the last song src, will have to wait for full song list to load.");
		}
	}

	/**
	 * Updates the given data as stringified JSON for the given key in the `localStorage`.
	 * @param key <str> the localStorage key to update
	 * @param data <?> the data.
	 * @param mode <int>, -1=delete, 0=overwrite, 1=append (if [existing type is array, and mode == 1])
	 */
	function update_persistent(key, data=null, mode=0) {
		if (mode in [-1, 0]) {
			localStorage.removeItem(key);
		}
		if (mode in [0, 1] && data != null) {
			var temp = JSON.parse(localStorage.getItem(key));
			if (Array.isArray(temp)) {
				temp = temp.concat(data);
			} else {
				temp = data;
			}
			localStorage.setItem(key, JSON.stringify(temp));
		}
	}
	
	/**
	 * @returns JSON.parse of the value stored at the `localStorage.key`.
	 * null if it does not exist.
	 */
	function load_persistent(key){
		return JSON.parse(localStorage.getItem(key));
	}
	
	/**
	 * load_ functions get the persistent data and updates their respective live values.
	 * save_ functions stores their respective live values to localStorage to be persistent.
	 */
	function load_playlist_data() {
		let enabled = (load_persistent('ALLOW_PERSISTENT_PLAYLIST') == null? false : load_persistent('ALLOW_PERSISTENT_PLAYLIST'));
		if (enabled) {
			document.getElementById("allow_persistent_playlist").checked = true;
			let plylst = load_persistent('PERSISTENT_PLAYLIST');
			plylst.forEach(e=>{/*if(e.src) {*/ add_song_record_to_playlist(e)}/*}*/)
		}
	}
	function save_playlist() {
		update_persistent('ALLOW_PERSISTENT_PLAYLIST', document.getElementById("allow_persistent_playlist").checked);
		if (document.getElementById("allow_persistent_playlist").checked) {
			update_persistent('PERSISTENT_PLAYLIST',PLAYLIST_SONGS/*.filter(e=>e.src)*/, 0);
		} else {
			// delete this data as its potential to be large* data footprint
			update_persistent('PERSISTENT_PLAYLIST',mode=-1);
			update_persistent('PERSISTENT_PLAYLIST_GEN_DATE',mode=-1);
		}
	}
	function load_volume() {
		document.getElementById("player").volume = (load_persistent('VOLUME') == null? 1 : load_persistent('VOLUME')); 
	}
	function save_volume() {
		update_persistent('VOLUME',document.getElementById("player").volume, 0);
	}
	function load_timestamps() {
		var timestamps = load_persistent('TIMESTAMPS');
		if (timestamps == null) {
			return;
		}
		var timestamp_list = document.querySelector('#timestamps_list');
		timestamps.forEach(ts => {
			var li = document.createElement("li");
			li.innerText = ts;
			timestamp_list.appendChild(li);
		});
	}
	function save_timestamps() {
		var arr = Array.from(new Set(Array.from(document.getElementById('timestamps_list').childNodes).map(e=>e.innerText)));
		update_persistent('TIMESTAMPS', arr, arr.length == 0? 0 : 1)
	}
	
	/**
	 * Fired by the clear timestamps button üÜë.
	 * Updates the UI and deletes its respective persistent data.
	 */
	function clear_timestamps() {
		var timestamps = document.getElementById('timestamps_list').childNodes;
		if (timestamps.length == 0) {return;}
		if (confirm("Are you sure you want to clear and reset all of the timestamps?")) {
			var removed = JSON.stringify(Array.from(timestamps).map(e=>e.innerText));
			while (timestamps.length) {
				timestamps[0].remove();
			}
			update_persistent('TIMESTAMPS', null, -1);
			//localStorage.removeItem('TIMESTAMPS');
			console.log(removed);
			navigator.clipboard.writeText(removed);
			alert("Console and current clipboard contents should contain JSON of removed data!");
		}
	}

	function setup_wake_lock_action_handlers() {
		if (!('wakeLock' in navigator)) {
			// remove useless elements from screen
			//document.querySelector("#screen_wake_lock_toggle").remove();
			//document.querySelector("#CSS_screen_wake_lock").remove();
			write2log(`Screen wait lock feature disabled, no 'wakeLock' in navigator`, mobileCheck() ? null : 10);
			//return;
		}
		const wakeLockToggle = document.querySelector("#screen_wake_lock_switch")
		window.screen_wake_lock = null;
		window.screen_wake_lock_mode = wakeLockToggle.checked;
		wakeLockToggle.onchange = async (e) => {
			if (e.target.checked) {
				window.screen_wake_lock = await request_screen_wake_lock();
			} else {
				// toggle off
				if (window.screen_wake_lock?.release) { 
					window.screen_wake_lock.release()
				}
			}
		}
	}
	var screen_wake_lock_request_lock = false;
	async function request_screen_wake_lock() {
		if (screen_wake_lock_request_lock) {
			write2log(`Screen wake lock request already in progress`, 1);
			return;
		}
		screen_wake_lock_request_lock = true;
		try {
			window.screen_wake_lock = await navigator.wakeLock.request('screen');
			window.screen_wake_lock.release = (event) => {
				const uiSwitch = document.querySelector("#screen_wake_lock_switch");
				if (uiSwitch.checked) {
					uiSwitch.checked = false;
				}
				write2log(`Screen wake lock has been released`, 60);
				// TODO: retry to get screen wake lock?
				if (!event.isTrusted) {
					// non user fired event
					write2log(`should i try to get new lock?`,60);
				}
			}
			screen_wake_lock_request_lock = true;
		} catch (err) {
			// if wake lock request fails - usually system related, such as battery
			write2log(`Failed to aquire screen wake lock!`, 60);
			write2log(err, 60);
			screen_wake_lock_request_lock = false;
		}
	}

	
	/**
	 * onload event:
	 * 1. Loads any persistent data.
	 * 2. Adds events to UI objects when they should become available.
	 * 3. Retreives the playlists.
	 * 4. Starts playing music.
	 */
	window.onload = async function() {
		load_volume();
		load_playlist_data();
		document.querySelector('#shuffle_button').addEventListener('click', function(){document.querySelector('#shuffle_button').innerText = document.querySelector('#shuffle_button').innerText == "üîÄ" ? "üîÉ" : "üîÄ"}, false);
		document.querySelector('#player_source').addEventListener('error', async function(err){ console.log(`Failed to load source value of ${this.src}`); check_for_updated_src(this.src); }, false);	
		start_quick_start_song();
		load_timestamps();
		setup_wake_lock_action_handlers();
		await update_playlist_songs();
		update_dropdown_with_current_songs();
		load_song_from_index(get_random_song_idx());
		document.querySelector('audio').addEventListener('ended', function(){ if (! document.querySelector('audio').seeking) load_song_from_index()}, false);
		document.querySelector('#songlist_selector').addEventListener('change', load_selected_song, false);
		document.querySelector('#skip').addEventListener('click', load_song_from_index, false);
		document.querySelector('#mark_timestamp').addEventListener('click', mark_favorited_timestamp, false);
		document.querySelector('#clear_timestamps').addEventListener('click', clear_timestamps, false);
		document.querySelector('#player_source').addEventListener('error', function(err){ if (! document.querySelector('audio').seeking) load_song_from_index()}, false);
		setup_media_session_action_handlers();
	}
	
	/** logs data to console and to visible element on page.
	 * #param val (any) the value to log
	 * @param timeout (number) if greater than 0, will remove the line from the log after timeout seconds.
	 * @returns the row element <tr> that was logged
 	*/
	function write2log(val, timeout = 0) {
			console.log(val);
			var ts = document.createTextNode(
				new Date().toLocaleTimeString("en-us", {
					hour12: false,
					hour: "2-digit",
					minute: "2-digit",
					second: "2-digit",
					fractionalSecondDigits: 3,
				})
			);
			var is_secondary_val_type = false;
			if (String(val) == "[object Object]") {
				val = JSON.stringify(val);
				is_secondary_val_type = true;
			}
			val = document.createTextNode(val);
			var newRow = document.createElement("tr");
			newRow.appendChild(document.createElement("td")).appendChild(ts);
			newRow.appendChild(document.createElement("td")).appendChild(val);
			if (is_secondary_val_type) {
				newRow.childNodes[1].style.color = "red";
			}
			var tbl = document.querySelector('#log_table_body');
			tbl.appendChild(newRow);
			tbl.hidden = false;
			if (timeout > 0) {
				removeFadeOutAfter(newRow, Math.max(timeout, 1));
			}
			return newRow;
		}
	/** Fades an element after a given time, and deletes the object from the DOM/memory.
	 * @param {HTMLElement} el the element to be dissapered
	 * @param {*} seconds the seconds to dissapear after
	 */
	function removeFadeOutAfter(el, seconds) {
		setTimeout(() => {
			el.style.transition = "opacity 1s ease";
			el.style.opacity = 0;
			setTimeout(function () {
				el.parentNode.removeChild(el);
			}, seconds * 1000);
		}, Math.max(seconds - 1, 1) * 1000);
	}
	/**
	 * @returns true if on mobile device, false otherwise.
	 */
	function mobileCheck() {
		return (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(navigator.userAgent||navigator.vendor||window.opera)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test((navigator.userAgent||navigator.vendor||window.opera).substr(0,4)));
	}
	
	/**
	 * onunload: Before closing down, save any persistent data that needs to be saved!
	 */
	window.onunload = function() {
		save_volume();
		save_timestamps();
		save_playlist();
	}
</script>
</head>
<body>
	<button id="PLAY" onclick="let x=document.querySelector('audio');document.querySelectorAll('[hidden]').forEach(e=>e.hidden=false);x.muted=true;x.muted=false;x.volume=mobileCheck()?1:(x.volume?x.volume : 1);x.play();document.querySelector('#PLAY').remove()">‚ñ∂Ô∏è</button>
	<div hidden>
		<select id="songlist_selector"><option>Loading...</option></select>
	</div>
	<div>
		<button id="shuffle_button" hidden>üîÄ</button>
		<button id="skip" hidden>‚è≠</button>
		<button id="mark_timestamp" hidden>‚≠ê</button>
		<label id="screen_wake_lock_toggle" class="slider-toggle-switch" for="screen_wake_lock_switch" data-size="" style="--slider-ts-input-checked-content: 'Screen wake locked';--slider-ts-input-unchecked-content: 'Screen sleep allowed';--slider-ts-width: 150px;" hidden>
			<input id="screen_wake_lock_switch" type="checkbox" />
			<span class="slider_toggle"><span class="slider_switch"></span></span>
		</label>
	</div>
	<div><audio controls autoplay id="player" hidden><source src="data:audio/ogg;base64,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GEMppJRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkgppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkqppJRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoplVJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSCgCQinAAkHowoQwUGrISAEgFAACMUUopxpyDEDHmGGPQSSgpYsw5xhyUklLlHIQQUmktt8o5CCGk1FJtmXNSWosx5hgz56SkFFvNOYdSUoux5ppr7qS0VmuuNedaWqs115xzzbm0FmuuOdecc8sx15xzzjnnGHPOOeecc84FAOA0OACAHtiwOsJJ0VhgoSErAYBUAAACGaUYc8456BBSjDnnHIQQIoUYc845CCFUjDnnHHQQQqgYc8w5CCGEkDnnHIQQQgghcw466CCEEEIHHYQQQgihlM5BCCGEEEooIYQQQgghhBA6CCGEEEIIIYQQQgghhFJKCCGEEEIJoZRQAABggQMAQIANqyOcFI0FFhqyEgAAAgCAHJagUs6EQY5Bjw1BylEzDUJMOdGZYk5qMxVTkDkQnXQSGWpB2V4yCwAAgCAAIMAEEBggKPhCCIgxAABBiMwQCYVVsMCgDBoc5gHAA0SERACQmKBIu7iALgNc0MVdB0IIQhCCWBxAAQk4OOGGJ97whBucoFNU6iAAAAAAAAwA4AEA4KAAIiKaq7C4wMjQ2ODo8AgAAAAAABYA+AAAOD6AiIjmKiwuMDI0Njg6PAIAAAAAAAAAAICAgAAAAAAAQAAAAICAT2dnUwAEAAAAAAAAAADwOoUqAgAAAJxxaEsBAQA=" type="audio/mp4" id="player_source"></audio></div>
	<div>
	<h4 hidden>Played history:</h4>
	<ul id="played_history_list" hidden></ul>
	<p hidden>TIMESTAMPS:&nbsp;<button id="clear_timestamps">üÜë</button></p>
	<ul id="timestamps_list" hidden></ul>
	</div>
	<label hidden><input type="checkbox" id="allow_persistent_playlist" > Enable persistent storage of playlist</label>
	<table id="log_table" >
		<thead id="log_table_header"><tr><th>timestamp</th><th>message</th></tr></thead>
		<tbody id="log_table_body"></tbody>
	</table>
</body>
</html>
